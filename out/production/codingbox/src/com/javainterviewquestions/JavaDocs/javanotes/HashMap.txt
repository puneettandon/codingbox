			HashMap in java 

HashMap is a part of Java's collection since java 1.2. 
It provides the basic implementation of the Map interface of Java.
It stores the data in (key,value)pairs.
To access a value one must know its key.
HashMap is known as HashMap because it uses a technique called Hashing.
Hashing is a technique of converting a large string to small string that represents the same String.
A shorter value helps in indexing and faster searches.
HashSet also uses HashMap internally.

Features of HashMap are: 
1) HashMap is part of java.util package
2) HashMap extends an abstract class AbstractMap which also provides the incompelete implementation of Map interface.
3) It also implements Cloneable and Serializable interface.
4) HashMap doesnot allow duplicate keys but allows duplicate values.
5) HashMap allows null key but only once and multiple null values.
6) This class makes no guarantees as to the order of the map; in particularly, it does not guarantee that the order will remain constant over time.
It is roughly similar to HashTable but is unsynchronized.

-----------------------------------------------------------------
	
		Internal Structure of HashMap

Internally HashMap contains an array of Node 
And Node is represented as a class which contains 4 fields.
	1) int hash
	2) K Key
	3) V value
	4) Node next

It can be seen that node is containing a reference of its own object. So it's a linkedlist.

HashMap: 
    
			




-----------------------------------------------------------------
			Performance of HashMap

Depends on 2 parameters: 
1. Initial Capacity
2. Load Factor

Capacity is simply the number of buckets whereas initial capacity is the capacity of hashmap instance when it is created.
The load factor is a measure that when rehashing should be done.
Rehashing is a process of increasing the capacity.

-----------------------------------------------------------------

		Synchronized HashMap

As it is told that HashMap is unsynchronized i.e. multiple threads can access it simultaneously.
If multiple threads access this class simultaneously and atleast one thread manipulates it structurally then it is neccessary to make it synchronized externally.
	Map m = Collections.synchronizedMap(new HashMap(...));

------------------------------------------------------------------

       		Time Complexity of HashMap

HashMap provides constant time complexity for basic operations, get and put if the hash function is properly written and it disperses the elements properly among the buckets.







-------------------------------------------------------------------------------------


		Constructors in HashMap

HashMakp() - initialCap - 16 and load factor 0.75
HashMap(int initialCapacity) 
HashMap(int initialCapactity,float loadfactor)
HashMap(Map map)



public class GFG{
	psvm(){
		HashMap<String,Integer> map = new HashMap<>();
		print(map);
		map.put("vishal",10);  map.put("sachin",20);   map.put("vaibhab",30);

		sys("Size of map is: "+map.size());

		print(map);
		
	}

	void print(Map<String,Integer> map){
		if(map.isEmpty())
			sys("map is empty");
		else
			sys(map);
	}
}


output:
map is empty
Size of map is: 3
{vaibhav=30,vishal=10,sachin=20}

------------------------------------------------------------------------------------


void clear()
boolean containsKey(Object key)
boolean containsValue(Object value)
Object clone(): shallow copy 
boolean isEmpty()
Set entrySet() return a set view of hashmap
Object get(Ojbect key)
Set keySet()  return a set view of the Keys
int size()
Object put(Object key,Object value) 
putAll(Map m)
Object remove(Object key)
Collection values()


------------------------------------------------------------------------------------

		Iteration any Map in Java


5 ways

First of all, we cannot iterate a Map directly using Iterators, because Map are not Collection. Also before going further, you must know a little bit about Map.Entry<K,V> interface.



1. Iterating Over Map.entrySet() using For-each loop:


class IterationDemo{

	psvm(){
		Map<String,String> gfg = new HashMap<String,String>();
		gfg.put("GFF","geeksforgeeks.org");
		gfg.put("udm","udemy.com");
		gfg.put("yt","youtube.com");
		gfg.put("jtp","javatpoint");

		for(Map.Entry<String,String> entry: map.entrySet())
			sys("key " + entry.getKey() + " ,value = "+entry.getValue());			
	}
}

output
key=GFF, value=geeksforgeeks.org
key=udm, value=udemy.com
key=yt, value=youtube.com
key=jtp, value=javatpoint

--------------------------------------------------

2. Iterating over key or values using keySet() and values() methods

class IterationDemo{
	psvm(){
		Map<String,String> gfg = new HashMap<String,String>();
		gfg.put("GFF","geeksforgeeks.org");
		gfg.put("udm","udemy.com");
		gfg.put("yt","youtube.com");
		gfg.put("jtp","javatpoint");
	
		for(String name: gfg.keySet())
			sys("key: "+name);
		for(String url: gfg.values())
			sys("value: "+url);
	}
}

output
key: GFF
key: udm
key: yt
key: jtp
value: geeksforgeeks.org
value: udemy.com
value: youtube.com
value: javatpoint

-------------------------------------------------------

3. Iterating using iterators over Map.Entry<K,V>

class IterationDemo{
	psvm(){
		Map<String,String> gfg = new HashMap<String,String>();
		gfg.put("GFF","geeksforgeeks.org");
		gfg.put("udm","udemy.com");
		gfg.put("yt","youtube.com");
		gfg.put("jtp","javatpoint");

		Iterator<Map.Entry<String,String>> itr = gfg.entrySet().iterator();
		while(itr.hasNext())
		{
			Map.Entry<String,String> entry =itr.next();
			sys("Key = "+entry.getKey() + " , value = "+entry.getValue());
		}		
	}	
}

4. Iterating over keys and searching for values(inefficient)

time consuming and slow

class IterationDemo{
	psvm(){
		Map<String,String> gfg = new HashMap<String,String>();
		gfg.put("GFF","geeksforgeeks.org");
		gfg.put("udm","udemy.com");
		gfg.put("yt","youtube.com");
		gfg.put("jtp","javatpoint");

		for(String name: gfg.keySet())
		{
			String url = gfg.get(name);			
			sys("key = "+name+ ", value= "+url);
		}
	}
}